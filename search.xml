<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BASE64编码在图片上传中的应用]]></title>
    <url>%2F2017%2F08%2F12%2FBASE64%E7%BC%96%E7%A0%81%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 在实际工作中，遇到许多同事，也包括网上的一些例子建议在图片上传过程中将图片转换成base64编码上传，问其原因，竟然没有人知道，只是说看到别人这么做了(⊙o⊙)… 正文 关于BASE64的利弊关于base64编码的原理就不在说了，可自行搜索，接下来说说上传base64编码的利弊。好处就是，把图片转换成base64编码后图片转换成了文本，可以嵌入css或者js文件中把图片缓存到本地，而不需要每次载入页面先从服务器获取src地址，然后在下载图片，大大减少http请求次数，减轻服务器压力，加快图片在页面的显示速度，而这在移动端应用中可以提高用户体验。有利的是可以作为文本，而弊端也是文本。对于前端，特别是移动端，把图片转换成base64编码会带来CPU的开销，而且编码后文本的大小比图片要增加1/3,也就是说上传一张图片消耗的流量增加1/3,这些对于手机端应用来说是不可容忍的。对于服务器端，还要把base64编码解析为图片，而且如果上传的base64编码过大，后端会报错，前端传入的参数也不会得到，post提交方式和http协议规范虽然没有对上传数据的大小有限制，但问题取决于服务器处理程序的处理能力，比如Tomcat服务器默认的post大小限制为2M。 图片转base64上传图片转base64上传的大致思路是前台传以data:image/jpeg;base64,开头的base64编码的String字符串，后台接收字符串以后先进行base64解码 .decodeBuffer()，转换成二进制编码，然后使用字节输出流FileOutputStream（）将文件保存到指定目录下。 Java将图片转base64public class ImageUtils { /** * 将网络图片进行Base64位编码 * @param imgUrl 图片的url路径 * @return */ public static String encodeImgageToBase64(URL imageUrl) { // 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 ByteArrayOutputStream outputStream = null; try { BufferedImage bufferedImage = ImageIO.read(imageUrl); outputStream = new ByteArrayOutputStream(); ImageIO.write(bufferedImage, &quot;jpg&quot;, outputStream); } catch (MalformedURLException e1) { e1.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(outputStream.toByteArray());// 返回Base64编码过的字节数组字符串 } /** * 将本地图片进行Base64位编码 * @param imgUrl 图片的url路径 * @return */ public static String encodeImgageToBase64(File imageFile) { // 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 ByteArrayOutputStream outputStream = null; try { BufferedImage bufferedImage = ImageIO.read(imageFile); outputStream = new ByteArrayOutputStream(); ImageIO.write(bufferedImage, &quot;jpg&quot;, outputStream); } catch (MalformedURLException e1) { e1.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(outputStream.toByteArray());// 返回Base64编码过的字节数组字符串 } } js将图片转base64//将图片转base64 function convertImgToBase64(url, callback, outputFormat){ var canvas = document.createElement(&apos;CANVAS&apos;), ctx = canvas.getContext(&apos;2d&apos;), img = new Image; img.crossOrigin = &apos;Anonymous&apos;; img.onload = function(){ canvas.height = img.height; canvas.width = img.width; ctx.drawImage(img,0,0); var dataURL = canvas.toDataURL(outputFormat || &apos;image/png&apos;); callback.call(this, dataURL); canvas = null; console.log(dataURL); }; img.src = url; } //测试 convertImgToBase64(&apos;http://p2.so.qhimgs1.com/sdr/720_1080_/t01d713cf1ad6717772.jpg&apos;, function(base64Img){ // Base64DataURL }); convertImgToBase64函数url可以是网络url也可以是本地的。 bitmap将图片转base64function GetBase64Code(path){//path绝对路径 var bitmap = new plus.nativeObj.Bitmap(&quot;test&quot;); //test标识谁便取 // 从本地加载Bitmap图片 bitmap.load(path,function(){ var base4=bitmap.toBase64Data(); var datastr=base4.split(&apos;,&apos;,3) if(datastr.length&gt;1) { pics.push(datastr[1]); }else { pics.push(datastr[0]); } console.log(&apos;加载图片：&apos;+base4); },function(e){ console.log(&apos;加载图片失败：&apos;+JSON.stringify(e)); }); } 这种方式在移动端应用中使用，兼容android和ios。 base64编码转图片文件后台接收到base64编码字符串后要转换成图片文件存放到服务器，这里指展示部分代码： 将base64编码转成二进制 imageFile = imageFile.replaceAll(&quot;data:image/jpeg;base64,&quot;, &quot;&quot;); BASE64Decoder decoder = new BASE64Decoder(); // Base64解码 byte[] imageByte = null; try { imageByte = decoder.decodeBuffer(imageFile); for (int i = 0; i &lt; imageByte.length; ++i) { if (imageByte[i] &lt; 0) {// 调整异常数据 imageByte[i] += 256; } } } catch (Exception e) { e.printStackTrace(); } 将二进制转成file文件 // 生成文件名 String files = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;) .format(new Date()) + (new Random().nextInt(9000) % (9000 - 1000 + 1) + 1000) + &quot;.png&quot;; // 生成文件路径 String filename = Constant.UPLOAD_PATH + files; try { // 生成文件 File imageFile = new File(filename); imageFile.createNewFile(); if(!imageFile.exists()){ imageFile.createNewFile(); } OutputStream imageStream = new FileOutputStream(imageFile); imageStream.write(imageByte); imageStream.flush(); imageStream.close(); } catch (Exception e) { e.printStackTrace(); } 总结 将图片转base64上传虽然能减少http请求次数，但是因为中间需要转码解码所以过程要多一些，我的建议是如果想要把图片缓存到本地，可以转base64后存到本地，上传时直接上传图片文件，现在的框架对文件的上传也有很好的支持。 参考 网站性能优化:base64:URL传输图片文件]]></content>
      <tags>
        <tag>Java学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数据传输中的加密与解密]]></title>
    <url>%2F2017%2F07%2F30%2Fjava%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[前言 在最近的工作中，用户需求要求在两个独立的系统通信中，要确保对外的接口不能被其他系统非法访问，这就涉及到了数据通信中对信息的加密和Token的验证，所以对这方面的知识做了一些了解。 正文 浅谈加密相关术语加密是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但不知道解密的方法，仍无法了解信息的内容。在加密系统中出现了一些重要的概念术语： 明文：未加密的数据（plaintext ）。 密文：明文经过加密后的数据（ciphertext ）。 加密：将明文转换为密文的过程(encryption) 。 解密：将密文转换为明文的过程(decryption) 。 加密算法：将明文转换为密文的转换算法。 解密算法：将密文转换为明文的转换算法 加密密钥：用于加密算法进行加密操作的密钥(encryption key)。 解密密钥：用于解密算法进行解密操作的密钥(decryption key)。 tip：加密算法和解密算法的操作通常是在一组密钥（ key ）的控制下进行的，分别称为加密密钥(encryption key) 和解密密钥(decryption key) 。 在加密系统中，加密算法和密钥是最重要的两个概念。在这里需要对加密算法和密钥进行一个解释。以最简单的“恺撒加密法”为例。 《高卢战记》有描述恺撒曾经使用密码来传递信息，即所谓的“ 恺撒密码” 。它是一种替代密码，通过将字母按顺序推后 3 位起到加密作用，如将字母 A 换作字母D，将字母 B换作字母E。如“China”可以变为“Fklqd”；解密过程相反。 在这个简单的加密方法中，“向右移位”，可以理解为加密算法；“3 ”可以理解为加密密钥。对于解密过程，“向左移位”，可以理解为解密算法；“3 ”可以理解为解密密钥。显然，密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的数据。 恺撒加密法的安全性来源于两个方面：第一，对加密算法的隐藏；第二，对密钥的隐蔽。单单隐蔽加密算法以保护信息，在学界和业界已有相当讨论，一般认为是不够安全的。公开的加密算法是给黑客长年累月攻击测试，对比隐蔽的加密算法要安全多。一般说来，加密之所以安全，是因为其加密的密钥的隐藏，并非加密解密算法的保密。而流行的一些加密解密算法一般是完全公开的。敌方如果取得已加密的数据，即使得知加密算法，若没有密钥，也不能进行解密。 常见的加密算法加密技术从本质上说是对信息进行编码和解码的技术。加密是将可读信息（明文）变为代码形式（密文），解密是加密的逆过程，相当于将密文变为明文。众多的加密手段大致可以分为单向加密和双向加密。单向加密指通过对数据进行摘要计算生成密文，密文不可逆推还原，比如有Base64、MD5、SHA等。双向加密则相反，指可以把密文逆推还原成明文。双向加密又分为对称加密和非对称加密。对称加密是指数据使用者必须拥有同样的密钥才可以进行加密解密，就像大家共同约定了以组暗号一样，对称加密的手段有DES、3DES、AES、IDEA、RC4、RC5等。而非对称加密相对于对称加密而言，无需拥有同一组密钥，它是一种信息公开的密钥交换协议。非对称加密需要公开密钥和私有密钥两组密钥，公开密钥和私有密钥是配对起来的，也就是说使用公开密钥进行数据加密，只有对应的私有密钥才能进行解密。此类加密手段有RSA、DSA等。 单向加密单向加密在加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，密文无法解密。只有重新输入明文，并经过同样的加密算法处理，得到相同的密文并被系统重新识别后，才能真正解密。该方法计算复杂，通常只在数据量有限的情形下使用。常见的单向加密方式有： BASE64 （严格地说，属于编码格式，而非加密算法） MD5（Message Digest Algorithm，信息摘要算法第五版） SHA（Secure Hash Algorithm，安全散列算法） HMAC(Hash Message Authentication Code，散列消息鉴别码) BASE64BASE64编码算法不算是真正的加密算法。Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。另，BASE加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。 /** * base64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) throws Exception { return (new BASE64Decoder()).decodeBuffer(key); } /** * base64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) throws Exception { return (new BASE64Encoder()).encodeBuffer(key); } tip：BASEEncoder和BASEDecoder是非官方JDK实现类。虽然可以在JDK里能找到并使用，但是在API里查不到。JRE 中 sun 和 com.sun 开头包的类都是未被文档化的，如果要使用需要下载sun.misc.BASE64Decoder.jar。 MD5Java一般需要获取对象MessageDigest来实现单项加密(信息摘要)，常用于文件校验。不管文件多大，经过MD5后都能生成唯一的MD5值。 public byte[] eccrypt(String info) throws NoSuchAlgorithmException{ //根据MD5算法生成MessageDigest对象 MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] srcBytes = info.getBytes(); //使用srcBytes更新摘要 md5.update(srcBytes); //完成哈希计算，得到result byte[] resultBytes = md5.digest(); return resultBytes; } MD5算法具有一下特点： 压缩性：任意长度的数据，算出的MD值长度都是固定的。 容易计算：从原数据计算出MD值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改个字节，所得到的MD值都有很大区别。 弱抗碰撞：已知原数据和其MD值，想找到一个具有相同MD值的数据（即伪造数据）是非常困难的。 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD值，是非常困难的。 SHASHA称为安全哈希算法。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。 public byte[] eccrypt(String info) throws NoSuchAlgorithmException{ MessageDigest sha = MessageDigest.getInstance(&quot;SHA&quot;); byte[] srcBytes = info.getBytes(); //使用srcBytes更新摘要 sha.update(srcBytes); //完成哈希计算，得到result byte[] resultBytes = sha.digest(); return resultBytes; } HMACHMAC(Hash Message Authentication Code)，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。 /** * 初始化HMAC密钥 * @return * @throws Exception */ public static String initMacKey() throws Exception { KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC); SecretKey secretKey = keyGenerator.generateKey(); return encryptBASE64(secretKey.getEncoded()); } /** * HMAC加密 * @param data * @param key * @return * @throws Exception */ public static byte[] encryptHMAC(byte[] data, String key) throws Exception { SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC); Mac mac = Mac.getInstance(secretKey.getAlgorithm()); mac.init(secretKey); return mac.doFinal(data); } 双向加密对称加密在对称加密算法中，双方使用的密钥相同，要求解密方事先必须知道加密密钥。其特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，通信双方都使用同样的密钥，安全性得不到保证。此外，用户每次使用该算法，需要保证密钥的唯一性，使得双方所拥有的密钥数量很大，密钥管理管理较为困难。 如上所述，对称加密算法过程中，发送方将明文和加密密钥一起经过加密算法处理，变成密文，发送出去；接收方收到密文后，使用加密密钥以及相同的算法的逆算法对密文解密，恢复为明文。双方使用的密钥相同，要求解密方事先必须知道加密密钥，从这里可以得出： 加密时使用什么密钥，解密时必须使用相同的密钥，否则无法解密。 对相同的信息，不同的密钥，加密结果和解密结果理论上不相同。 现在介绍三种常用的对称加密算法：DES、3DES和AES。 DESDES 是数据加密标准（Data Encryption Standard）的简称，出自 IBM 的研究工作。 import java.io.UnsupportedEncodingException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.Security; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import org.junit.Test; import com.thinkgem.jeesite.common.utils.Base64; public class DesTest { //KeyGennrator提供对称密钥生成器的功能，支持各种算法 private KeyGenerator keygen; //SecretKey负责保存对称密钥 private SecretKey deskey; //Cipher负责完成加密或解密工作 private Cipher c; //保存加密的结果 private byte[] cipherByte; public DesTest(){ Security.addProvider(new com.sun.crypto.provider.SunJCE()); try{ //实例化支持DES 算法的密钥生成器(算法名称命名需按规定，否则抛出异常) keygen = KeyGenerator.getInstance(&quot;DES&quot;); // 生成密钥 deskey = keygen.generateKey(); // 生成Cipher 对象，指定其支持DES 算法 c = Cipher.getInstance(&quot;DES&quot;); }catch(NoSuchAlgorithmException ex){ ex.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } } /** * @desc 对字符串str 加密 * @author yaotengfei * @date 2017年8月2日下午3:17:19 * @param str * @return */ public byte[] createEncryptor(String str){ try{ // 根据密钥，对Cipher 对象进行初始化,ENCRYPT_MODE 表示加密模式 c.init(Cipher.ENCRYPT_MODE, deskey); byte[] src = str.getBytes(&quot;UTF-8&quot;); // 加密，结果保存进cipherByte cipherByte = c.doFinal(src); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return cipherByte; } /** * @desc 对字节数组buff 解密 * @param buff * @return */ public byte[] createDecryptor(byte[] buff){ try{ // 根据密钥，对Cipher 对象进行初始化,ENCRYPT_MODE 表示解密模式 c.init(Cipher.DECRYPT_MODE, deskey); // 得到明文，存入cipherByte字符数组 cipherByte = c.doFinal(buff); }catch(java.security.InvalidKeyException ex){ ex.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } return cipherByte; } /** * @desc 测试 */ @Test public void test(){ DesTest desTest = new DesTest(); String msg = &quot;rickZone&quot;; System.out.println(&quot;明文：&quot;+msg); //加密 byte[] enc = createEncryptor(msg); System.out.println(&quot;密文：&quot;+new String(Base64.encode(enc))); //解密 byte[] dec = desTest.createDecryptor(enc); System.out.println(&quot;解密后：&quot;+new String(dec)); } } 运行结果： 明文：rick&apos;Zone 密文：PhbGVjfHArXWgF/GflRfxA== 解密后：rick&apos;Zone 在上面的代码中，不同情况下，密文的内容会不一样，因为KeyGenerator每次生成的密钥是随机的。在输出密文的时候为了可读性，可以把密文转换成Base64编码，否则显示的是乱码。 3DES3DES，也称为3DESede或TripleDES，是三重数据加密，并且可以逆推的一种算法方案，通过对DES算法进行改进，针对每个数据块进行三次DES加密，也就是3DES加密算法。java使用3DES加密解密的流程为： 传入共同的密钥（keyBytes）以及算法（Algorithm），来构建SecretKey密钥对象。SecretKey deskey = new SecretKeySpec(keyBytes, Algorithm); 根据算法实例化Cipher对象。它负责加密/解密。Cipher c1 = Cipher.getInstance(Algorithm); 传入加密/解密模式以及SecretKey密钥对象，实例化Cipher对象。c1.init(Cipher.ENCRYPT_MODE, deskey); 传入字节数组，调用Cipher.doFinal()方法，实现加密/解密，并返回一个byte字节数组。c1.doFinal(src); 3DES加密代码： import java.io.UnsupportedEncodingException; import java.security.InvalidKeyException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import org.junit.Test; import com.thinkgem.jeesite.common.utils.Base64; public class Test_3DES { //定义加密算法，有DES、DESede(即3DES)、Blowfish private static final String Algorithm = &quot;DESede&quot;; private static final String PASSWORD_CRYPT_KEY = &quot;201231332322&quot;; /** * @desc 加密方法 * @param src 源数据的字节数组 * @return */ public static byte[] encryptMode(byte[] src){ try{ SecretKey deskey = new SecretKeySpec(build3DesKey(PASSWORD_CRYPT_KEY), Algorithm); //生成密钥 Cipher c1 = Cipher.getInstance(Algorithm); //实例化负责加密/解密的Cipher工具类 c1.init(Cipher.ENCRYPT_MODE, deskey); //初始化为加密模式 return c1.doFinal(src); }catch(java.security.NoSuchAlgorithmException e1){ e1.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; } /** * @desc 解密函数 * @param src 密文的字节数组 * @return */ public static byte[] decryptMode(byte[] src) { try{ SecretKey deskey = new SecretKeySpec(build3DesKey(PASSWORD_CRYPT_KEY), Algorithm); Cipher c1 = Cipher.getInstance(Algorithm); c1.init(Cipher.DECRYPT_MODE, deskey); //初始化为解密模式 return c1.doFinal(src); }catch(java.security.NoSuchAlgorithmException e1){ e1.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return null; } /** * @desc 根据字符串生成密钥字节数组 * @param keyStr 密钥字符串 * @return * @throws UnsupportedEncodingException */ public static byte[] build3DesKey(String keyStr) throws UnsupportedEncodingException{ byte[] key = new byte[24]; //声明一个24位的字节数组，默认里面都是0 byte[] temp = keyStr.getBytes(&quot;UTF-8&quot;); //将字符串转成字节数组 if(key.length &gt; temp.length){ //如果temp不够24位，则拷贝temp数组整个长度的内容到key数组中 System.arraycopy(temp, 0, key, 0, temp.length); }else{ //如果temp大于24位，则拷贝temp数组24个长度的内容到key数组中 System.arraycopy(temp, 0, key, 0, key.length); } return key; } /** * @desc 测试 */ @Test public void test(){ String msg = &quot;rick&apos;Zone&quot;; System.out.println(&quot;明文：&quot;+msg); //加密 byte[] secretArr = encryptMode(msg.getBytes()); System.out.println(&quot;密文：&quot;+Base64.encode(secretArr)); //解密 byte[] myMsgArr = decryptMode(secretArr); System.out.println(&quot;解密后：&quot;+new String(myMsgArr)); } } 3DES的密钥必须是24位的byte数组，随便拿一个String.getBytes()是不行的，会报如下错误： java.security.InvalidKeyException: Invalid key length: 10 bytes 解决的办法有很多：1、按密钥固定长度重新定义字符串；2、先把字符串用Base64或者MD5加密，然后截取固定长度的字符转成byte数组；3、字符串转成Byte数组，针对该数组进行修改，若长度过长则只截取一部分，若长度不够则补零。加密的结果的编码方式要一致，从byte数组转成字符串，一般有两种方式，base64处理和十六进制处理。 AESAES 在密码学中是高级加密标准（Advanced Encryption Standard ）的缩写。AES 作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优点。 import java.security.Security; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import org.junit.Test; import com.thinkgem.jeesite.common.utils.Base64; public class Aes { @Test public void test() throws Exception{ //KeyGenerator提供对称密钥生成器的功能，支持各种算法 KeyGenerator keygen; //SecretKey 负责保存对称密钥 SecretKey deskey; //Cipher 负责完成加密或解密工作 Cipher c; Security.addProvider(new com.sun.crypto.provider.SunJCE()); // 实例化支持AES 算法的密钥生成器，算法名称用AES keygen = KeyGenerator.getInstance(&quot;AES&quot;); // 生成密钥 deskey = keygen.generateKey(); // 生成Cipher 对象，指定其支持AES 算法 c = Cipher.getInstance(&quot;AES&quot;); String msg = &quot;rick_zone&quot;; System.out.println(&quot;明文是：&quot; + msg); // 根据密钥，对Cipher 对象进行初始化,ENCRYPT_MODE表示加密模式 c.init(Cipher.ENCRYPT_MODE, deskey); byte[] src = msg.getBytes(); // 加密，结果保存进enc byte[] enc = c.doFinal(src); System.out.println(&quot;密文是：&quot; + Base64.encode(enc)); // 根据密钥，对Cipher 对象进行初始化,ENCRYPT_MODE表示加密模式 c.init(Cipher.DECRYPT_MODE, deskey); // 解密，结果保存进dec byte[] dec = c.doFinal(enc); System.out.println(&quot;解密后的结果是：&quot; + new String(dec)); } } 运行结果： 明文是：rick_zone 密文是：hpff0pxvbDt+ECtyPYiBKg== 解密后的结果是：rick_zone 非对称加密非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。每个人拥有这两个密钥，公开密钥对外公开，私有密钥不公开。如果用公开密钥对数据进行加密，只有相对应的私有密钥才能解密；如果私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。非对称加密加密算法的基本过程是： 通信前，接收方随机生成公钥，发送给发送方，自己保留私钥。 发送方利用接收方的公钥加密明文，使其变为密文。 接收方收到密文后，使用自己的密钥解密密文。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要，但加密和解密花费时间长、速度慢，它不适合于对文件加密而适用于对少量数据进行加密。 RSARSA是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。这这种加密算法的特点主要是密钥的变化，上面的对称加密算法中只有一个密钥。相当于只有一把钥匙，如果这把钥匙丢了，数据也就不安全了。RSA同时有两把钥匙，公钥与私钥。同时支持数字签名。数字签名的意义在于，对传输过来的数据进行校验。确保数据在传输工程中不被修改。RSA流程分析： 1、乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开；2、得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方；3、乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密；4、乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息；5、在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文； import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.Signature; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Map; import javax.crypto.Cipher; import com.google.common.collect.Maps; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; /** * @desc RSA加密解密 */ public class RSACoder { //定义加密方式 private final static String KEY_RSA = &quot;RSA&quot;; //定义签名算法 private final static String KEY_RSA_SIGNATURE = &quot;MD5withRSA&quot;; //定义公钥算法 private final static String KEY_RSA_PUBLICKEY = &quot;RSAPublicKey&quot;; //定义私钥算法 private final static String KEY_RSA_PRIVATEKEY = &quot;RSAPrivateKey&quot;; /** * @desc 初始化密钥 * @return */ public static Map&lt;String, Object&gt; init(){ Map&lt;String, Object&gt; map = null; try { KeyPairGenerator generator = KeyPairGenerator.getInstance(KEY_RSA); generator.initialize(1024); KeyPair keyPair = generator.generateKeyPair(); // 公钥 RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); // 私钥 RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); // 将密钥封装为map map = Maps.newHashMap(); map.put(KEY_RSA_PUBLICKEY, publicKey); map.put(KEY_RSA_PRIVATEKEY, privateKey); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return map; } /** * @desc 用私钥对信息生成数字签名 * @param data 加密数据 * @param privateKey 私钥 * @return */ public static String sign(byte[] data,String privateKey){ String str = &quot;&quot;; try { // 解密由base64编码的私钥 byte[] bytes = decryptBase64(privateKey); // 构造PKCS8EncodedKeySpec对象 PKCS8EncodedKeySpec pkcs = new PKCS8EncodedKeySpec(bytes); // 指定的加密算法 KeyFactory factory = KeyFactory.getInstance(KEY_RSA); // 取私钥对象 PrivateKey key = factory.generatePrivate(pkcs); // 用私钥对信息生成数字签名 Signature signature = Signature.getInstance(KEY_RSA_SIGNATURE); signature.initSign(key); signature.update(data); str = encryptBase64(signature.sign()); } catch (Exception e) { e.printStackTrace(); } return str; } /** * @desc 校验数字签名 * @param data 加密数据 * @param publicKey 公钥 * @param sign 数字签名 * @return 校验成功返回true，失败返回false */ public static boolean verify(byte[] data, String publicKey, String sign) { boolean flag = false; try { // 解密由base64编码的公钥 byte[] bytes = decryptBase64(publicKey); // 构造X509EncodedKeySpec对象 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes); // 指定的加密算法 KeyFactory factory = KeyFactory.getInstance(KEY_RSA); // 取公钥对象 PublicKey key = factory.generatePublic(keySpec); // 用公钥验证数字签名 Signature signature = Signature.getInstance(KEY_RSA_SIGNATURE); signature.initVerify(key); signature.update(data); flag = signature.verify(decryptBase64(sign)); } catch (Exception e) { e.printStackTrace(); } return flag; } /** * @desc 私钥解密 * @param data 加密数据 * @param key 私钥 * @return */ public static byte[] decryptByPrivateKey(byte[] data, String key) { byte[] result = null; try { // 对私钥解密 byte[] bytes = decryptBase64(key); // 取得私钥 PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes); KeyFactory factory = KeyFactory.getInstance(KEY_RSA); PrivateKey privateKey = factory.generatePrivate(keySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(factory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); result = cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return result; } /** * @desc 公钥解密 * @param data 加密数据 * @param key 公钥 * @return */ public static byte[] decryptByPublicKey(byte[] data, String key) { byte[] result = null; try { // 对公钥解密 byte[] bytes = decryptBase64(key); // 取得公钥 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes); KeyFactory factory = KeyFactory.getInstance(KEY_RSA); PublicKey publicKey = factory.generatePublic(keySpec); // 对数据解密 Cipher cipher = Cipher.getInstance(factory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicKey); result = cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return result; } /** * @desc 公钥加密 * @param data 待加密数据 * @param key 公钥 * @return */ public static byte[] encryptByPublicKey(byte[] data, String key) { byte[] result = null; try { byte[] bytes = decryptBase64(key); // 取得公钥 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes); KeyFactory factory = KeyFactory.getInstance(KEY_RSA); PublicKey publicKey = factory.generatePublic(keySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(factory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicKey); result = cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return result; } /** * @desc 私钥加密 * @param data 待加密数据 * @param key 私钥 * @return */ public static byte[] encryptByPrivateKey(byte[] data, String key) { byte[] result = null; try { byte[] bytes = decryptBase64(key); // 取得私钥 PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes); KeyFactory factory = KeyFactory.getInstance(KEY_RSA); PrivateKey privateKey = factory.generatePrivate(keySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(factory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateKey); result = cipher.doFinal(data); } catch (Exception e) { e.printStackTrace(); } return result; } /** * @desc 获取公钥 * @param map * @return */ public static String getPublicKey(Map&lt;String, Object&gt; map) { String str = &quot;&quot;; try { Key key = (Key) map.get(KEY_RSA_PUBLICKEY); str = encryptBase64(key.getEncoded()); } catch (Exception e) { e.printStackTrace(); } return str; } /** * @desc 获取私钥 * @param map * @return */ public static String getPrivateKey(Map&lt;String, Object&gt; map) { String str = &quot;&quot;; try { Key key = (Key) map.get(KEY_RSA_PRIVATEKEY); str = encryptBase64(key.getEncoded()); } catch (Exception e) { e.printStackTrace(); } return str; } /** * @desc BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryptBase64(String key) throws Exception { return (new BASE64Decoder()).decodeBuffer(key); } /** * @desc BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBase64(byte[] key) throws Exception { return (new BASE64Encoder()).encodeBuffer(key); } /** * @desc 测试 */ public static void main(String[] args) { String privateKey = &quot;&quot;; String publicKey = &quot;&quot;; // 生成公钥私钥 Map&lt;String, Object&gt; map = init(); publicKey = getPublicKey(map); privateKey = getPrivateKey(map); System.out.println(&quot;公钥: \n\r&quot; + publicKey); System.out.println(&quot;私钥： \n\r&quot; + privateKey); System.out.println(&quot;公钥加密--------私钥解密&quot;); String word = &quot;你好，世界！&quot;; byte[] encWord = encryptByPublicKey(word.getBytes(), publicKey); String decWord = new String(decryptByPrivateKey(encWord, privateKey)); System.out.println(&quot;加密前: &quot; + word + &quot;\n\r&quot; + &quot;解密后: &quot; + decWord); System.out.println(&quot;私钥加密--------公钥解密&quot;); String english = &quot;Hello, World!&quot;; byte[] encEnglish = encryptByPrivateKey(english.getBytes(), privateKey); String decEnglish = new String(decryptByPublicKey(encEnglish, publicKey)); System.out.println(&quot;加密前: &quot; + english + &quot;\n\r&quot; + &quot;解密后: &quot; + decEnglish); System.out.println(&quot;私钥签名——公钥验证签名&quot;); // 产生签名 String sign = sign(encEnglish, privateKey); System.out.println(&quot;签名:\r&quot; + sign); // 验证签名 boolean status = verify(encEnglish, publicKey, sign); System.out.println(&quot;状态:\r&quot; + status); } } 测试结果： 公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQblxGcna68ErW1gy02oGZsCvuddliTp8HMXJh k8Fgfy337dMb293uHNYmUmhsP0Jlkku1+5H53fb2iP9lYlZbCATjtKw9pSWeabMYizSoV1vRXvHc ts3vGn3efeJUf6IU7pAFihe9zmrCWuNdNfSp+ZrgYUNKVYOB+6S1ktPSsQIDAQAB 私钥： MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANBuXEZydrrwStbWDLTagZmwK+51 2WJOnwcxcmGTwWB/Lfft0xvb3e4c1iZSaGw/QmWSS7X7kfnd9vaI/2ViVlsIBOO0rD2lJZ5psxiL NKhXW9Fe8dy2ze8afd594lR/ohTukAWKF73OasJa41019Kn5muBhQ0pVg4H7pLWS09KxAgMBAAEC gYEAiPV7vO7KBdyP0MumXdCXCJ4yv+bAiVCQPvHG70df8kCfvCKSbePz2Nsp/NR5uWd4AbY3+cTt DvtDpIwxBjWv98CswHgwqKEq6hLleCNiC2FSikXywJ0RkU6IPx1L0d4P5e9YhYwU4xADk0M8n3KD rzzP1NLdoNJ4/DQk5jsQUIECQQD6F4HCLxIJJtZb/lOlaegYB+8teXIrXrRdhcmZrBuD75Jow/lO 26AqF6QRwKGQmFSGljUCPRjSsvkRifsUGZ3VAkEA1VrmXUuolCCTRzSVqxfxi0nsOZKg83n8rO7e mIfuQn/WdyicxxX65WQTo9PqNaFgVkBwYmLcPY+IN9qPUDmjbQJAetK0nWN0nh3+xKtA9Unv/G1Z H6I3Welm909PVTNbSA6OfvlQJVRjcoitwTIzpsnJKVf3rKPI3yGahOyY7KQwCQJBAKnTbya4AHnX 7CNzoebMakHbF6NEKcVkRlJI2PpEyMw6AbZbp195CXrqTA/NsNH7oDlHla1az8BYra7307eiCYkC QQDl1M+re4CgRJCy/mCdoymR108+BVlABVIF6Y7ihGEYLiznwRXyz/vxgu2YlOR/DLNIS4tgGY9v o6D1xDF39H2N 公钥加密--------私钥解密 加密前: 你好，世界！ 解密后: 你好，世界！ 私钥加密--------公钥解密 加密前: Hello, World! 解密后: Hello, World! 私钥签名——公钥验证签名 签名: kOWUL2Rvu7VGStpo4Qh+a9tNeASXdk6cxHXYUG4ExQQpiKD0ApPkby7yfrLX7qPgwmK5UGnDw9CW w1LbgvEObc9/HY0zdgWbh8t67tQz6xVcVPT3fNxpcnUi4e/Pe0+TdISQ/xmqh/S9tHncCMAvB3OJ +eULz1x3fE0RjIqhGVw= 状态: true 看似很复杂的过程，用一句话就可以描述：使用公钥加密、私钥解密，完成了乙方到甲方的一次数据传递，通过私钥加密、公钥解密，同时通过私钥签名、公钥验证签名，完成了一次甲方到乙方的数据传递与验证，两次数据传递完成一整套的数据交互。 总结 本文介绍了常用的各种加密方法，在这里只介绍如何使用，不做深入探究，如果想深入了解，也可以查其他书籍资料，以及参考中的博客文章。里面还包括其他的未提到的加密算法。在后面的博客中介绍base64编码和非对称加密在实际项目中的应用。 参考 java加密技术]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（三）：面向切面的Spring]]></title>
    <url>%2F2017%2F07%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84Spring%2F</url>
    <content type="text"><![CDATA[前言 一个成熟的软件系统包括许多功能，比如日志，安全和事务管理器等，这些功能需要用到应用程序的多个地方，但是我们又不想在每个点都明确调用它们。如果让应用对象只关注于自己所针对的业务，而其他的问题由其他的应用对象来处理，这会不会更好呢？在软件开发中，散布于应用中多处的功能被称为横切关注点，这些横切关注点从概念上是与应用的业务逻辑相分离的。把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP)所要解决的问题。 正文 什么是面向切面编程在软件开发过程中，如果要重用通用功能的话，最常见的面向对象技术是继承或者委托。但是，如果在整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系，而使用委托可能需要对委托对象进行复杂的调用。切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要的关注点的代码，而次要关注点的代码被转移到切面中了。 AOP术语 AOP已经形成了自己的术语。描述切面的常用术语有通知（advice）、切点（pointcut）、和连接点（join point）。 通知（Advice） 在上面我们介绍了什么是切面————需要通用的代码被模块化为特殊的类。类似地，切面也有目标：它必须要完成的工作。在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？Spring切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和之后执行自定义的行为。 连接点（Join point） 我们的应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点（Point） 一个切面不需要通知应用的所有连接点，而切点有助于缩小切面通知的连接点的范围。如果说通知定义了切面的“什么”和“何时”，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。 切面（Aspect） 切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。 引入（Introduction） 引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。 织入（Weaving） 织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译器：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载器：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。 我们已经了解了一些基础的AOP术语，现在让我们再看看这些AOP的核心概念是如何在Spring中实现的。 Spring对AOP的支持并不是所有的AOP框架都是相同的，它们在连接点模型上可能有强弱之分。但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。 通过切点来选择连接点切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面的最基本元素。因此，了解如何编写切点非常重要。在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器的一个子集。下表列出了Spring AOP所支持的AspectJ 切点表达式语言来定义Spring切面： 在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgument-Exception异常。在上面所展示的这些Spring支持的指示器时，只有execution指示器时实际执行匹配的，其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器。在此基础上，我们使用其他指示器来限制所匹配的切点。 编写切点为了阐述Spring中的切面，我们定义一个Performance接口： package concert; public interface Performance{ public void perform(); } Performance可以代表任何类型的现场表演。假设我们编写Performance的perform()方法触发的通知： 上图展现了一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。我们使用execution()指示器选择Performance的perform()方法。方法表达式以“*”号开始，表明了我们不关心方法返回值类型。然后，我们指定了全限定类名和方法名。对于方法参数列表，我们使用两个点号（..）表明切点要选择任意的perform()方法，无论该方法的入参是什么。现在假设我们需要配置的切点仅匹配concert包，可以使用winthin()指示器来限制匹配： 我们使用了“&amp;&amp;”操作符把execution()和winthin()指示器连接在一起形成与（and）关系。类似地，我们可以使用“||”操作符来标识或（or）关系，而使用“!”操作符来标识非（not）操作。因为“&amp;”在XML中有特殊含义，所以在Spring的XML配置里面描述切点时，我们可以使用and来代替“&amp;&amp;”。同样，or和not可以分别用来代替“||”和“!”。 在切点中选择bean除了Spring支持的指示器外，Spring还引入了一个新的bean()指示器，它允许我们我们在切点表达式中使用bean的ID来标识bean。bean()使用bean ID或则bean名称作为参数来限制切点只匹配特定的bean： execution（* concert。Performance.perform()) and bean(&apos;woodstock&apos;) 在这里，我们希望在执行Performance的perform()方法时应用通知，但限定bean的ID为woodstock。在某些场景下，限定切点为指定的bean获取很有意义，但我们还可以使用非操作为除了特定ID以外的其他bean应用通知： execution（* concert.Performance.perform()) and !bean(&apos;woodstock&apos;) 在此场景下，切面的通知会被编织到所有ID不为woodstock的bean中。 使用注解创建切面使用注解来创建切面是AspectJ 5所引入的关键特性。AspectJ面向注解的模型可以非常简便地通过少量注解把任意类转换成切面。我们已经定义了Performance接口，它是切面中切点的目标对象。现在，我们使用AspectJ注解来定义切面。 定义切面从演出的角度来看，观众是非常重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观众定义为一个切面，并将其应用到演出上。 package concert @Aspect public class Audience{ //表演之前 @Before(&quot;execution(** concert.Performance.perform(..))&quot;) public void silenceCellPhones(){ System.out.println(&quot;Silencing cell phones&quot;); } //表演之前 @Before(&quot;execution(** concert.Performance.perform(..))&quot;) public void takeSeats(){ System.out.println(&quot;Taking seats&quot;); } //表演之后 @AfterReturning(&quot;execution(** concert.Performance.perform(..))&quot;) public void applause(){ System.out.println(&quot;CLAP CLAP CLAP CLAP!!!&quot;); } //表演失败之后 @AfterThrowing(&quot;execution(** concert.Performance.perform(..))&quot;) public void demandRefund(){ System.out.println(&quot;Demanding a refund&quot;); } } Audience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。可以看到，这些方法都使用了通知注解来表明他们应该在什么时候调用。AspectJ提供了五个注解来定义通知： Audience使用到了前五个注解中的三个。takeSeats()和silence CellPhones()方法都用到了@Before注解，表明它们应该在演出开始之前调用。applause()方法使用了@AfterReturning注解，它会在演出成功返回后调用。demandRefund()方法上添加了@AfterThrowing注解，这表明它会在抛出异常以后执行。在上面的这些注解都给定了一个切点表达式作为它的值，同时这四个方法的切点表达式都是相同的。其实，它们可以设置成不同的切点表达式。相同的切点表达式我们重复了四遍，如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好的方案。我们可以使用@Pointcut注解能够在一个@AspectJ切面内定义可重用的切点： package concert @Aspect public class Audience{ //定义命名的切点 @Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;) public void performance(){} //表演之前 @Before(&quot;performance()&quot;) public void silenceCellPhones(){ System.out.println(&quot;Silencing cell phones&quot;); } //表演之前 @Before(&quot;performance()&quot;) public void takeSeats(){ System.out.println(&quot;Taking seats&quot;); } //表演之后 @AfterReturning(&quot;performance()&quot;) public void applause(){ System.out.println(&quot;CLAP CLAP CLAP CLAP!!!&quot;); } //表演失败之后 @AfterThrowing(&quot;performance()&quot;) public void demandRefund(){ System.out.println(&quot;Demanding a refund&quot;); } } 在Audience中，performance()方法使用了@Pointcut注解。为@Pointcut注解设置的值是一个切点表达式，就像之前在通知注解上所设置的那样。通过在performance()方法上添加@Pointcut注解，我们实际上扩展了切点表达式语言，这样就可以在任何的切点表达式中使用performance()了，如果不这样做的话，你需要在这些地方使用那个更长的切点表达式。我们现在把所有通知注解中的长表达式都替换成了performance()。Performance()方法的实际内容并不重要，在这里它实际上应该是空的。其实该方法本身只是一个标识，供@Pointcut注解依附。需要注意的是，除了注解和没有实际操作的performance()方法，Audience类依然是一个POJO。我们能够像使用其他的Java类那样调用它的方法，它的方法也能够独立地进行单元测试，这与其他的Java类并没有什么区别。Audience只是一个Java类，只不过它通过注解表明会作为切面使用而已。像其他的java类一样，它可以装配为Spring中的bean： @Bean public Audience audience（）{ return new Audience(); } 如果就此止步的话，Audience只是Spring容器中的一个bean。即便使用了AspectJ注解，但它并不会被视为切面，这些注解不会解析，也不会创建将其转换为切面的代理。 如果你使用javaConfig的话，可以在配置类的类级别上通过使用EnableAspectj-AutoProxy注解启用自动代理功能： package concert; @Configuration @EnableAspectJAutoProxy //启用AspectJ自动代理 @ComponentScan public class ConcertConfig{ @Bean public Audience audience(){ //声明Audience bean return new Audience(); } } 假如你在Spring中要使用XML来装配bean的话，那么需要使用Spring AOP命名空间中的元素： &lt;context:component-scan base-package=&quot;concert&quot; /&gt; &lt;!-- 启用AspectJ自动代理 --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 声明Audience bean --&gt; &lt;bean class=&quot;concert.Audience&quot; /&gt; 不管你是使用JavaConfig还是XML，AspectJ自动代理都会为使用@Aspect注解的bean创建一个代理，这个代理会围绕着所有该切面的切点所匹配的bean。在这种情况下，将会为Concertbean创建一个代理，Audience类中的通知方法将会在perform()调用前后执行。Spring的AspectJ自动代理仅仅使用@AspectJ作为创建切面的指导，切面依然是基于代理的。在本质上，它依然是Spring基于代理的切面。这一点非常重要，因为这意味着尽管使用的是@AspectJ注解，但我们仍然限于代理方法的调用。如果想利用AspectJ的所有能力，我们必须在运行时使用AspectJ并且不依赖Spring来创建基于代理的切面。 创建环绕通知环绕通知是最强大的通知类型。他能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。我们使用环绕通知重新实现Audience切面： package concert @Aspect public class Audience{ //定义命名的切点 @Pointcut(&quot;execution(** concert.Performance.perform(..))&quot;) public void performance(){} //环绕通知方法 @Around(&quot;performance()*) public void watchPerformance(ProceedingJoinPoint jp){ try{ System.out.println(&quot;Silencing cell phones&quot;); System.out.println(&quot;Taking seats&quot;); jp.proceed(); System.out.println(&quot;CLAP CLAP CLAP!!!&quot;); }catch(Throwable e){ System.out.println(&quot;Demanding a refund&quot;); } } } @Around注解表明watchPerformance()方法会作为performance()切点的环绕通知。在这个通知中，观众在演出前会将手机调至静音并就坐，演出结束后会鼓掌喝彩，如果演出失败，观众会要求退款。在这个新的通知方法中，ProceedingJoinPoint作为参数，这个对象必须有，因为你还要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用ProceedingJoinPoint的proceed()方法。如果不调用这个方法，你的通知实际上会阻塞对被通知的调用。 在XML中声明切面在Spring开发中中我们基于这样一种原则：基于注解的配置要优于基于java的配置，基于java的配置要优于基于XML的配置。但是，如果要声明切面，但是又不能为通知类添加注解时，就必须转向XML配置了。在Spring的aop命名空间中，提供了许多元素用来在XML中声明切面： aop命名空间的元素能够让我们直接在Spring配置声明切面，而不需要注解。我们重新看一下Audience类，我们将所有的AspectJ注解去掉 package concert public class Audience{ public void performance(){} public void silenceCellPhones(){ System.out.println(&quot;Silencing cell phones&quot;); } public void takeSeats(){ System.out.println(&quot;Taking seats&quot;); } public void applause(){ System.out.println(&quot;CLAP CLAP CLAP CLAP!!!&quot;); } public void demandRefund(){ System.out.println(&quot;Demanding a refund&quot;); } } Audience类现在没有任何特别之处，就是有几个方法的简单java类。我们可以像其他类一样把它注册为Spring应用上下文中的bean。 声明前置和后置通知现在我们通过XML将无注解的Audience声明为切面： &lt;aop:config&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;!-- 引用Audience bean --&gt; &lt;aop:before pointcut=&quot;execution(**concert.Performance.perform(..))&quot; method=&quot;silenceCellPhones&quot; /&gt; &lt;aop:before pointcut=&quot;execution(**concert.Performance.perform(..))&quot; method=&quot;takeSeats&quot; /&gt; &lt;aop:after-returning pointcut=&quot;execution(**concert.Performance.perform(..))&quot; method=&quot;applause&quot; /&gt; &lt;aop:after-throwing pointcut=&quot;execution(**concert.Performance.perform(..))&quot; method=&quot;demandRefund&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 在基于AspectJ注解的通知中，我们使用@pointcut注解消除了这些重复的内容，而在基于XML的切面声明中，我们需要使用元素： &lt;aop:config&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;!-- 引用Audience bean --&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut id=&quot;performance&quot; expression=&quot;execution(**concert.Performance.perform(..))&quot; /&gt; &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;silenceCellPhones&quot; /&gt; &lt;aop:before pointcut-ref=&quot;performance&quot; method=&quot;takeSeats&quot; /&gt; &lt;aop:after-returning pointcut-ref=&quot;performance&quot; method=&quot;applause&quot; /&gt; &lt;aop:after-throwing pointcut-ref=&quot;performance&quot; method=&quot;demandRefund&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 现在切点是在一个地方定义的，并且被多个通知元素所引用。 声明环绕通知我们在使用前置通知和后置通知的时候如果不使用成员变量存储信息的话，在前置通知和后置通知之间共享信息非常麻烦。例如，我们希望观众确保一直关注演出，并报告每个参赛者表演了多长时间。使用前置通知和后只通知实现该功能的唯一方式是在前置通知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成员变量中保存开始时间。因为Audience是单例的，如果这样的话，将会存在线程安全问题。 如果使用环绕通知，我们可以完成前置和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑是在一个方法内实现的，所以不需要使用成员变量保存信息。在上面的Audience类的watchPerformance()方法中，去掉注解： package concert public class Audience{ public void watchPerformance(ProceedingJoinPoint jp){ try{ System.out.println(&quot;Silencing cell phones&quot;); System.out.println(&quot;Taking seats&quot;); jp.proceed(); //执行被通知的方法 System.out.println(&quot;CLAP CLAP CLAP!!!&quot;); }catch(Throwable e){ System.out.println(&quot;Demanding a refund&quot;); } } } 声明环绕通知与声明其他类型的通知并没有太大的区别，我们需要做的就是使用元素： &lt;aop:config&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;!-- 引用Audience bean --&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut id=&quot;performance&quot; expression=&quot;execution(**concert.Performance.perform(..))&quot; /&gt; &lt;!-- 声明环绕通知 --&gt; &lt;aop:around pointcut-ref=&quot;performance&quot; method=&quot;watchPerformance&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 指定了一个切点和一个通知方法的名字。在这里，我们使用跟之前一样的切点，但是为该切点所设置的method属性值为watchPerformance()方法。 总结 AOP是面向对象编程的一个强大补充。通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这有效减少了代码冗余，并让我们的类关注自身的主要功能。Spring提供了一个AOP框架，让我们把切面插入到方法执行的周围。现在我们已经学会如何把通知织入前置、后置和环绕方法的调用中，以及为处理异常增加自定义的行为。 参考 Spring实战]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>SpringAOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（二）：装配Bean]]></title>
    <url>%2F2017%2F07%2F17%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[前言 在Spring中，对象无需自己查找或创建与其所关联的其他对象，相反，容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间的协作关系的行为通常称为装配，这也是依赖注入的本质，本篇将介绍使用Spring装配bean的基础知识。 正文 在Spring中装配bean有多种方式： Spring配置的可选方案在上篇描述中，Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将它们装配在一起。Spring提供了三种主要的装配机制： 在XML中进行显示配置。 在java中进行显示配置。 隐式的bean发现机制和自动装配。 这三种配置可以随意搭配，但是我们在工作中建议用的是第三种自动装配机智。显示配置越少越好。而也有些时候我们不得不使用显示配置，不如有些代码不是你来维护的，但你需要为这些代码配置bean的时候。首先我们先看一下Spring的自动化配置。 自动化装配beanSpring从两个角度来实现自动化装配： 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。 自动装配（autowiring）：Spring自动满足bean之间的依赖。 组件扫描和自动装配在一起能够使你的显示配置降低到最少。 创建可被发现的bean为了阐述组件扫描和装配，我们需要创建几个bean，比如在一个印象系统中的组件。首先创建CompactDisc类，Spring发现它并将其创建一个bean，然后创建一个CDPlayer类，让Spring发现它，并将CompactDiscbean注入进来。首先我们定义一个CD的接口： package soundsystem; public interface CompactDisc{ void paly(); } 我们还需要一个CompactDisc的实现，并且带有@Component注解： package soundsystem @Component public class SgtPeppers implements CompactDisc{ public void play(){ System.out.println(&quot;play music&quot;); } } 上面SgtPeppers类中使用了@Component注解，这个注解表明该类会作为组件类，并告诉Spring为这个类创建bean，而没有必要显示配置bean。但是Spring的组件扫描默认是不启用的，我们还需要显示配置一下Spring，从而命令Spring去寻找带有 @Component 注解的类，并为其创建bean，下面代码展示了完成这项任务最简洁的配置： package soundsystem; @Configuration @ComponentScan public class CDPlayerConfig{ } CDPlayerConfig类通过java代码定义了Spring的装配规则，与上一篇中通过java配置的代码不同的是我们并没有声明任何bean，只不过它使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包，CDPlayerConfig类位于soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类，这样就能发现CompactDisc类，并会在Spring中自动为其创建一个bean。当然你也可以使用XML来启用组件扫描： &lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt; 这样，Spring就创建了SgtPeppersbean，如果想要把这个bean注入到目标bean中只需要使用@Autowired就可以了： @AutoWired private CompactDisc cd; 为组件扫描的bean命名现在，我们来探讨一下@ComponentScan和@Component。Spring应用上下文中所有的bean都会给定一个ID，在上面的例子中，虽然我们没有明确为SgtPeppersbean设置iD，但Spring会根据类名为其指定一个ID，就是将类名的第一个字母变为小写，那么SgtPeppersbean的ID就是sgtPeppersbean。如果想为这个bean设置不同的ID，比如想将这个bean标识为longlyHeartsClub,那么需要将SgtPeppersbean类的@Component注解配置如下： @Component(&quot;longlyHeartsClub&quot;) public class SgtPeppers implements CompactDisc{ ··· } tip：还有一种为bean命名的方式，不使用@Component注解，而是使用java依赖注入规范中所提供的@Named注解为bean设置ID，但是在实际工作中很少使用，这里不再叙述。 设置组件扫描的基础包上面代码中我们使用@ComponentScan注解可以命令Spring扫描配置类所在包以及子包来发现组件。但是如果你想扫描不同的包或者想扫描多个基础包，又该怎么办呢？ 比如我们想把配置类单独放在一个包中，与其他的应用代码区分开，如果是这样的话，那默认的基础包就不能满足要求了。如果要满足上述需求，你所需要做的就是在@ComponentScan的value属性中指明包的名称： @Configuration @ComponentScan(&quot;soundsystem&quot;) public class CDPlayerConfig{} 如果想更清晰地表明你所设置的基础包，那么你可以通过basePackages属性进行配置： @Configuration @ComponentScan(basePackages=&quot;soundsystem&quot;) public class CDPlayerConfig{} 如果你的配置文件在不同的基础包中，只需要将basePackages属性设置为要扫描包的一个数组即可： @Configuration @ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;,···}) public class CDPlayerConfig{} 在上述代码中基础包是以String类型表示的，但这种方法是类型不安全的，如果你重构代码的话，那么所指定的基础包可能就会出现错误了。另一种方法就是将其指定为包中所含的类或者接口： @Configuration @ComponentScan(basePackageClasses={CDPlayer.calss,&quot;DVDPlayer.calss&quot;,···}) public class CDPlayerConfig{} 可以看到，basepackages属性变成了basePackageClasses.而且我们不再使用String类型的名称来指定包，而是设置了类，这些类所在的包将作为组件扫描的基础包。 通过为bean添加注释实现自动装配现在我们已经知道如何将一个类命名为一个bean，接下来就是如何自动装配他们了。自动装配就是就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配。我们可以借助Spring的@Autowired注解。 package soundsystem; @Component public class CDPlayer implementsMediaPlayer{ private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd){ this.cd = cd; } public void play(){ cd.play(); } } 在上述代码中CDPlayer类的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器來实例化并传入一个可设置的CompactDisc类型的bean。@Autowired不进能用在构造器上，还能用在属性的Setter方法上，不管是构造器还是Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖，加入有且只有一个bean匹配以来需求的话，那么这个bean将被装配进来。如果没有匹配的bean，那么应用上下文创建的时候，Spring就会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false: @Autowired(required=false) public CDPlayer(CompactDisc cd){ this.cd = cd; } 将required设置为false时，Spring会尝试执行自动装配，如果没有匹配的bean的话，Spring会让这个bean处于未装配的状态，但是把required属性设置为false时，如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。如果有多个bean能满足依赖关系的话，Spring将抛出一个异常，表明没有明确指定选择哪个bean进行自动装配。 tip：和@Component一样，@Autowired也有一个备胎：@Inject。@Inject注解来源于java依赖注入规范，在自动装配中，Spring同时支持@Autowired和@Inject，不过在工作中@Autowired更常见。 通过java代码装配bean尽管通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但是有时候自动化配置的方案是行不通的，比如你想要将第三方库中的组件装配到你都应用中，在这种情况下是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能是用自动化装配的方案了。在这种情况下，你必须要才用显示装配的方式。在进行显示装配的时候有两种可选的方案：java和XML。在进行显示配置时，javaConfig是更好的方案，因为它更强大、类型安全并且对重构友好。因为它就是java代码，就想应用程序中的其他java代码一样。同时，javaConfig与其他的java代码又有所不同，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样是用相同的语言，但javaConfig是配置代码，它不应该包含任何业务逻辑，javaConfig也不应该侵入到业务逻辑代码中。通常会将javaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来。 创建配置类接下来，让我们通过javaConfig显示配置Spring。在上面的CDPlayerConfig.java中我们使用的就是javaConfig： package soundsystem; @Configuration @ComponentScan public class CDPlayerConfig{ } 创建javaConfig类的关键在于为其添加@Configuration注解，@Configuration的注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。到此为止，我们都是依赖组件扫描來发现Spring应该创建的bean。而本节关注的重点是显示配置，我们将@ComponentScan注解去掉。 移除了@ComponentScan注解，此时的CDPlayerConfig类就没有任何作用了。如果你强行运行程序的话就会出现BeanCreation-Exception异常。这是因为bean根本就没有创建。 声明简单的bean要在javaConfig中声明bean，我们需要编写要给方法，这个方法创建所需要类型的实例，然后给这个方法添加@Bean注解： @Bean public CompactDisc sgtPeppers(){ return new SgtPeppers(); } @Bean注解会告诉Spring这个方法将返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。默认情况下，bean的ID与带有@Bean注解的方法名是一样的，上面代码中的bean的ID是sgtPeppers，如果想为其设置不同的名字，可以重命名该方法，通过name属性指定一个不同的名字： @Bean(name=&quot;lonelyHeartsClubBand&quot;) public CompactDisc sgtPeppers(){ return new SgtPeppers(); } 现在，我们借助@Bean命名了一个bean，那么我们怎么将这个bean注入到其他bean中呢？ 借助javaConfig实现注入前面我们声明了CompactDisc bean，它是一个非常简单的bean，并没有任何功能，我们需要声明一个CDPlayer bean，它依赖于CompactDisc。在javaConfig中装配bean的最简单的方式就是引用创建bean的方法。例如下面是一种声明CDPlayer的方案： @Bean public CDPlayer cdPlayer(){ return new CDPlayer(sgtPeppers()); } cdPlayer()方法像sgtPeppers()方法一样，同样使用了@Bean注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。在这里cdPlayer()方法调用了需要传入CompactDisc对象的构造器來创建CDPlayer实例。看起来，CompactDisc是通过调用sgtPeppers()得到的，但实际并非如此，因为sgtPeppers()方法上添加了@Bean注解，Spring将会链接所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。比如假设你引入了一个其他的CDPlayer bean，它和之前的那个bean完全一样： @Bean public CDPlayer cdPlayer(){ return new CDPlayer(sgtPeppers()); } @Bean public CDPlayer anothierCDPlayer(){ return new CDPlayer(sgtPeppers()); } 假如对sgtPeppers()的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的SgtPeppers实例。但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayer bean创建完全相同的SgtPeppers实例。所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。 通过XML装配bean到此为止，我们已经让Spring自动发现和装配bean,而且还知道如何通过javaConfig显示装配bean。但是在装配bean的时候，还有一种可选的方案：XML配置。需要说明的是在实际工作中我们已经不再使用XML配置了，更多的是通过注解或者javaConfig的方式。 创建XML配置规范在是用javaConfig的时候，我们需要写@Configuration注解來告诉Spring这是一个javaConfig的配置，而在XML中我们要创建一个XML文件，并要以元素为根。最简单的Spring XML配置如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context&quot;&gt; &lt;!-- 具体配置内容 --&gt; &lt;/beans&gt; 在使用XML时，需要在配置文件顶部声明多个XML文件，这些文件定义了配置Spring的XML元素。就这样我们就有了一个合法的SpringXML配置，不过，它是一个没有任何用处的配置，因为它还没有声明任何bean。接下来我们用XML配置來创建一个bean。 声明一个简单的bean在XML中我们使用Spring-bean模式中的一个元素：。元素类似于javaConfig中的@Bean注解。我们可以按照如下的方式声明CompactDisc bean： &lt;bean class=&quot;soundsystem.SgtPeppers&quot; /&gt; 这里我们声明了一个简单的bean，创建这个bean的类通过class属性來指定。因为没有给定ID，所以这个bean将会根据全限定类名來进行命名。在本例中，bean的ID将会是“soundsystem.SgtPeppers#0”。其中，“#0”是一个计数的形式，用来区分相同类型的其他bean。如果你声明了另一个SgtPeppers,并且没有明确给定ID，那么它自动得到的ID将会是“soundsystem.SgtPeppers#1”。为了方便，更好的办法就是为每个bean设置一个名字： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt; 现在，我们就声明了一个简单的bean。当Spring发现这个元素时，它将会调用SgtPeppers的默认构造器來创建bean。 借助构造器注入初始化bean在Spring XML配置中，只有一种声明bean的方式：使用元素并指定class属性。Spring会从这里获取必要的信息来创建bean。但是，在XML中声明DI时，会有多种可选的配置方案和风格。具体到构造器注入，有两种基本的配置方案可供选择： 元素 使用Spring3.0所引入的c-命名空间 两者的区别在很大程度就是是否冗长繁琐。 构造器注入bean引用按照前面的定义，CDPlayer bean接收CompactDisc类型的构造器。现在我们已经声明了SgtPeppers bean，并且SgtPeppers类实现了CompactDisc接口，我们现在要做的就是在XML中声明CDPlayer并通过ID引用SgtPeppers： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt; &lt;constructor-arg ref=&quot;compactDisc&quot; /&gt; &lt;/bean&gt; 当Spring遇到这个元素时，它会创建一个CDPlayer实例。元素会告知Spring要将一个ID为compactDisc的bean引用传递到CDPlayer的构造器中。 你也可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中引入的，它是在XML中更为简洁地描述构造器参数的方式。要使用它的话，必须在XML的顶部声明其模式： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/c&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ··· &lt;/beans&gt; 在c-命名空间和模式声明之后，我们就可以使用它来声明构造器参数了： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot; /&gt; 这里我们使用了c-命名空间来声明构造器参数。 属性名以“c:”开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后是“-ref”，这是一个命名的约定，它会告诉Spring，正在装配的是一个bean的引用，这个bean的名字是compactDisc，而不是字面量“compactDisc”。在上面的代码中我们使用了构造器参数的名称，还有一个可替代的方案： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot; /&gt; 这里的配置是吧参数的名字替换成了“0”，也就是参数的索引，因为XML中不允许数字作为属性的第一个字符，因此必须要添加一个下划线作为前缀。当构造器有多个参数的时候这种方式更为简便，如果只有一个构造器参数，我们还有另外一种方案： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot; /&gt; 这里没有参数索引或则参数名，只有一个下划线，然后就是用”ref-“来表明正在装配的是一个引用。 将字面量注入到构造器中现在我们所做的DI通常是指类型的装配，也就是将对象的引用装配到依赖于它们的其他对象中，而有时候，我们需要做的只是用一个字面量值来配置对象。如下： package soundsystem public class BlankDisc implements CompactDisc{ private String title; private String artist; public BlankDisc(String title,String artist){ this.title = title; this.artist = artist; } public void play(){ System.out.println(&quot;Playing&quot;+title+&quot;by&quot;+artist); } } 在SgtPeppers中，唱片名称和艺术家的名字都是硬编码的，但这个CompactDisc实现与之不同，它可以设置成任意的艺术家和唱片名，现在我们可以使用这个方案： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;titleName&quot; /&gt; &lt;constructor-arg value=&quot;artistNmae&quot; /&gt; &lt;/bean&gt; 我们再次使用元素进行构造器参数的注入。但是这一次我们没有使用“ref”属性来引用其他的bean，而是使用了value属性，通过该属性表明给定的值要以字面量的形式注入到构造器之中。 如果使用c-命名空间的花，这个例子变成了如下： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;titleName&quot; c:_artist=&quot;artistName&quot; /&gt; 可以看到，装配字面量与装配引用的区别在于属性名中去掉了“-ref”后缀。与之类似，我们也可以通过参数索引装配相同的字面量值，如下所示： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_0=&quot;titleName&quot; c:_1=&quot;artistName&quot; /&gt; XML不允许某个元素的多个属性具有相同的名字。因此，如果有两个或更多的构造器参数的话，我们不能简单地使用下画线进行标示。但是如果只有一个构造器参数的话，我们就可以这样做了： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_=&quot;titleName&quot; /&gt; 装配集合到现在为止，我们假设CompactDisc在定义时只包含了唱片名称和艺术家的名字。而现实中的CD还应该有不少于一首的歌曲，那么BlankDIsc就变成了下面的情况： import soundsystem.CompactDisc; public class BlankDisc implements CompactDisc { private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc(String title, String artist, List&lt;String&gt; tracks) { this.title = title; this.artist = artist; this.tracks = tracks; } public void play() { System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist); for (String track : tracks) { System.out.println(&quot;-Track: &quot; + track); } } } 这个变更会对Spring如何配置bean产生影响，在声明bean的时候，我们必须要提供一个歌曲列表。 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;titleName&quot; /&gt; &lt;constructor-arg value=&quot;artistName&quot; /&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;songName_1&lt;/value&gt; &lt;value&gt;songName_2&lt;/value&gt; &lt;value&gt;songName_3&lt;/value&gt; ··· &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 其中，元素是的子元素，这表明一个包含值的列表将会传递到构造器中。其中，元素用来指定列表中的每个元素。与之类似，我们也可以使用元素替代。 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;titleName&quot; /&gt; &lt;constructor-arg value=&quot;artistName&quot; /&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean=&quot;songName_1&quot; /&gt; &lt;ref bean=&quot;songName_2&quot; /&gt; &lt;ref bean=&quot;songName_3&quot; /&gt; ··· &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 我们也可以按照同样的方式使用元素： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;titleName&quot; /&gt; &lt;constructor-arg value=&quot;artistName&quot; /&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;value&gt;songName_1&lt;/value&gt; &lt;value&gt;songName_2&lt;/value&gt; &lt;value&gt;songName_3&lt;/value&gt; ··· &lt;/set&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 和元素的区别不大，其中最重要的不同在于当Spring创建要装配的集合时，所创建的是java.util.Set还是java.util.List。如果是Set的话，所有重复的值都会被忽略掉，存放顺序也不会得以保证。不过无论在哪种情况下，或都可以用来装配List、Set甚至数组。在装配集合方面，比c-命名空间的属性更有优势。目前，使用c-命名空间的属性无法实现装配集合的功能。 导入和混合配置在Spring应用中，我们可能同时使用自动化和显示配置。在Spring中这些配置方案都不是互斥的，你可以将javaConfig的组件扫描和自动化装配或XML配置混合在一起。 在javaConfig中引用XML配置假设现在有两个javaConfig配置类，我们可以在一个javaConfig中使用@Import注解导入另一个配置类： @Configuration @Import(CDConfig.class) //导入CDConfiug.java public class CDPlayerConfig{···} 或者采用一个更好的方法，创建一个更高级的配置类，在这个类中使用@Import将两个配置类组合在一起： @Configuration @Import(CDConfig.class，CDPlayerConfig.class) //导入CDConfiug.java、CDPlayerConfig.java public class SoundSystemConfig{···} 现在，如果我们希望在javaConfig类导入XML配置呢，我们可以用@ImportResource注解来实现： @Configuration @Import(CDConfig.class) //导入CDConfiug.java @ImportResource(&quot;classPath:cd-config.xml&quot;) //导入cd-config.xml public class SoundSystemConfig{···} 在XML配置中引入javaConfig上面说了如何通过@Import和@ImportResource来拆分JavaConfig类。那么我们是否也可以把XML拆分呢。事实上，答案并非如此，元素只能导入其他的XML配置文件，并没有XML元素能导入javaConfig类。但是，有一个元素能够用来将java配置导入到XML配置中：元素。为了将javaConfig类导入到XML配置中，我们可以这样声明bean： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;soundsystem.CDConfig&quot; /&gt; &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot; /&gt; &lt;/beans&gt; 采用这样的方式，两种配置————其中一个使用XML描述，另一个使用java描述————被组合在了一起。类似地，你可能还希望创建一个更高层次的配置文件，这个文件不声明任何的bean，只是负责将两个或更多的配置组合起来。例如，你可以将CDConfig bean从之前的XML文件中移除掉，而是使用第三个配置文件将这两个组合在一起： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;soundsystem.CDConfig&quot; /&gt; &lt;import resource=&quot;cdplayer-config.xml&quot; /&gt; &lt;/beans&gt; 不管使用JavaConfig还是使用XML进行装配，我通常都会创建一个根配置（root configuration），也就是这里展现的这样，这个配置会将两个或更多的装配类和/或XML文件组合起来。我也会在根配置中启用组件扫描（通过或@ComponentScan） 总结 我们看到了在Spring中装配bean的三种主要方式：自动化配置、基于Java的显式配置以及基于XML的显式配置。建议尽可能使用自动化配置，以避免显式配置所带来的维护成本。但是，如果你确实需要显式配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全并且易于重构。 参考 Spring教程]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring装配Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（一）：Spring初识]]></title>
    <url>%2F2017%2F07%2F16%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpring%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言 Spring是一个开源框架，，Spring可以做非常多的事情，但归根到底支撑Spring的仅仅是少许的基本理念，所有的理念都可以追溯到Spring最根本的使命上：简化java开发。Spring是如何简化java开发的？为了降低java开发的复杂性，Spring采取了一下4中关键策略： 基于POJO的轻量级和最小侵入性的编程。 通过依赖注入和面向接口实现松耦合。 基于切面和惯例进行声明式编程。 通过切面和模版减少样板式代码。 几乎Spring所做的任何事情都可以追溯到上述的一条或多条策略。 正文 激发POJO的潜能什么是POJO首先，什么是POJO。POJO（Plain Ordinary java Object）简单的java对象，实际就是普通的javaBeans，是为了。。。等等，那什么是javaBean，从大学开始就一直听说javaBean，当时就是一个简单的对象。 上面是百度百科的简介，总的来说就是符合一定规范的（其实也没有严格的规范）java对象。而POJO就是普通的javaBean，使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑。 此bean非彼bean虽然Spring用Bean或者javaBean來标识应用组件，（那什么是组件，暂且理解为为了实现Spring功能的工具吧，比如，你要修理自行车，而扳手就相当于一个组件）但并不意味着Spring组件必须要遵循javaBean规范，一个Spring组件可以是任何形式的POJO。那问题來了，java的bean和Spring中的bean有什么区别呢？可以说是javabean的发展，但已经完全不是一回事儿了。 用处不同：传统的javabean更多地作为值传递参数，而Spring中的bean用处几乎无处不在，任何组件都可以被称为bean。 写法不同：传统javabean作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法。 生命周期不同：传统javabean作为值对象传递，不接受任何容器管理其生命周期；spring中的bean有spring管理其生命周期行为。 所有可以被spring容器实例化并管理的java类都可以称为bean。SpringBean。如果是用过其他框架会发现很多框架通过强迫应用继承他们的类或者实现他们当接口从而导致应用与框架绑死。而Spring竭力避免因自身的API而弄乱你的应用代码，不会强迫你实现Spring规范的接口或继承Spring规范的类，最多就是一个类或许会是用Spring注解，但他依旧是POJO。举个例子： public classHelloWorldBean{ public String sayHello(){ return &quot;Hello Wordl&quot;; } } 可以看到，这是一个简单普通的java类，没有任何地方表明它是一个Spring组件。Spring的非侵入编程模型意味着这个类在Spring应用和非Spring应用中都可以发挥同样的作用。那么Spring是如何是用的它们的呢。Spring通过DI來装配它们。 依赖注入任何一个有实际意义的应用都会由两个或者更多的类组成，这些类相互之间进行协作来完成特定的业务逻辑。按照传统的做法，每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代码。举个例子： public class LearnJava implements Student{ private LearnJavaSkill learn; //学习java的能力 public LearnJava(){ this.learn = new LearnJavaSkill(); } public void toLearn(){ learn.toLearnJava(); //学习java } } 比如代码中一个学生想要学习java，就要有学习java的能力，于是new了个LearnJavaSkill(),这样使得 LearnJava和LearnJavaSkill耦合到了一起，这个学生java学的很好，但如果还想学C，就爱莫能助了。耦合具有两面性，一方面紧密耦合的代码难以测试，难以复用，另一方面，一定程度的耦合也是必须的，为了完成一些功能，耦合是必须的。通过DI（依赖注入），对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系 public class SmartStudent implements Student{ private Learn learn; //学习能力 //learn被注入 public smartStudent(Learn learn){ this.learn = learn; } public void learnJava(){ learn.toLearnJava(); } } 聪明的学生都具有很强的学习能力。可以看到不同于之前的LearnJava，学生没有自行创建学习英语的能力，而是在构造的时候把学习能力作为构造器的参数传递进来，这样学生就具有了很强的学习能力了。这是依赖注入的方式之一：构造器注入。而传入的learn类型是Learn，也就是说所有的学习任务只要实现Learn接口，学生具有了学习java、PHP、C++的能力就可以轻松学习java，PHP或则C++了。这里的学生没有和特定的学习任务发生耦合，对于学生来说，学习能力很强，那么至于学什么对于学生来说都可以轻松应对。现在聪明的学生可以具有你传递给他的任何学习能力，但怎么才能吧某个学习能力传递给他呢，加入学生想学习java，则上面两种方法都适用，但如果学生想学PHP呢。 public class LearnPHP implements Learn{ public void learnPHP(){ log(&quot;Hello PHP&quot;); } } 创建应用组件（smartStudent和learnPHP就是Spring组件）之间协作的行为通常称为装配。Spring有多种装配bean的方式，才用XML是常见的一种。下面的配置文件student.xml将smartStudent和learnPHP装配到了一起： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 声明SmartStudent为bean --&gt; &lt;bean id=&quot;smartStudent class=&quot;xx.xx.SmartStudent&quot;&gt; &lt;constructor-arg ref=&quot;learnPHP&quot; /&gt; &lt;/bean&gt; &lt;!-- 声明LearnPHP为bean --&gt; &lt;bean id=&quot;learnPHP&quot; class=&quot;xx.xx.LearnPHP&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; Spring配置文件中标签把smartStudent和learnPHP声明为标签（bean中的id只是bean的唯一标识）。是用把另一个bean注入。如果你不喜欢XML不符合你的习惯，Spring还支持是用java來描述配置信息。比如下面的java配置和上面的配置文件作用一致： @Configuration public class StudentConfig{ @Bean public Student smartStudent(){ return new SmartStudent(learnPHP()); } @Bean public Learn learnPHP(){ log(&quot;Hello PHP&quot;); } } 不管是用XML还是java配置，DI已经声明了smartStudent和learnPHP的关系，接下来我们只需要装载XML配置文件，并把应用启动起来。Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来，Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们的区别仅仅在于如何加载配置。因为student.xml中的bean是使用XML文件进行配置的，所以选择ClassPathCmlApplicationContext作为应用上下文相对是比较合适的（对于基于java的配置，Spring提供了AnnotationConfigApplicationContext）。该类加载位于应用程序类路径下的一个或者多个XML配置文件。 public class SmartStudentMain { public static void main(String[] args) throws Exception { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;META-INF/spring/student.xml&quot;); //加载Spring上下文 SmartStudent smartStudent = context.getBean(smartStudent.class); //获取smartStudent bean smartStudent.learnPHP(); //使用smartStudent context.close(); } } 这里的main()是基于配置文件创建了Spring应用上下文。 应用切面DI能够让软件组件保持松散耦合，面向切面编程（AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。一个可用的系统由许多不同的组件组成，每一个组件各负责一块特定的功能，除了实现自身核心的功能之外，这些组件还经常承担这额外的职责，如日志，事务管理和安全这样的服务。如果将这些关注点分散到多个组件中去，你的代码将会带来复杂性。AOP能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。学生学完相关课程，老师想要检验一下学生的学习效果，就要在学生学习之前和学习后出测试题，下面的代码定义了考试的功能 public class Teacher{ private Exam exam; //老师的考试功能 //注入exam public Teacher(Exam exam){ this.exam = exam; } //学习前调用 public void examBeforeLearn(){ exam.log(&quot;Don&apos;t pass&quot;); } //学习后调用 public void examAfterLearn(){ exam.log(&quot;pass&quot;); } } 上面的Teacher.java有两个方法，在学生学习前examBeforeLearn()被调用，在学生学习完后examAfterLearn()方法被调用，输出考试结果。如果想要把功能实现就要把Teacher.java放入smartStudent.java中，smartStudent就必须要调用Teacher， public class SmartStudent implements Student{ private Learn learn; //学习能力 private Teacher teacher; //learn被注入 public smartStudent(Learn learn){ this.learn = learn; } public void learnJava(){ teacher.examBeforeLearn(); //学习前调用 learn.toLearnJava(); teacher.examAfterLearn(); //学习后调用 } } 剩下要做的就是在Spring配置文件中声明Teacher为bean，然后把Teacher注入到smartStudent中，这样程序就能运行起来。一切看起来都很完美，但是仔细想想，老师考试学生应该是老师的分内事儿，不需要学生去调用他，而且，如果老师要老师学生就必须把老师注入进来，如果有些学生不需要被老师检测，如果teacher为null呢，那我们还要判断这些超出预期的功能，那么smartStudent类就变的越来越复杂。如果把Teacher抽象为一个切面，无论你想不想考试，老师就在那，不离不弃。你需要做的就是在Spring中声明老师为一个切面： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 声明SmartStudent为bean --&gt; &lt;bean id=&quot;smartStudent class=&quot;xx.xx.SmartStudent&quot;&gt; &lt;constructor-arg ref=&quot;learnPHP&quot; /&gt; &lt;/bean&gt; &lt;!-- 声明LearnPHP为bean --&gt; &lt;bean id=&quot;learnPHP&quot; class=&quot;xx.xx.LearnPHP&quot;&gt; &lt;/bean&gt; &lt;!-- 声明Teacher为bean --&gt; &lt;bean id=&quot;teacher&quot; class=&quot;xx.xx.Teacher&quot;&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;teacher&quot;&gt; &lt;!-- 定义切点 --&gt; &lt;aop:pointcut id=&quot;toLearnJava&quot; expression=&quot;execution(* *.toLearnJava(..))&quot;/&gt; &lt;!-- 声明前置通知 --&gt; &lt;aop:before pointcut-ref=&quot;toLearnJava&quot; method=&quot;examBeforeLearn&quot;/&gt; &lt;!-- 声明后置通知 --&gt; &lt;aop:after pointcut-ref=&quot;toLearnJava&quot; method=&quot;examAfterLearn&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 上面的配置把Teacher声明了一个切面。只需要声明在toLearnJava()方法执行前运行examBeforeLearn(),在toLearnJava()方法执行后运行examAfterLearn()。这样SmartStudent.java就和Teacher解耦了。 使用模版消除板式代码想象一下当我们第一次使用jdbc的时候，首先你得创建一个数据库链接，然后创建一个语句对象，最后才能进行查询，而且为了异常还要捕捉SQLException,最后还要关闭数据库链接、语句、和结果集，依然要捕捉SQLException。只有少量相关业务逻辑代码。其他的代码都是jdbc的样式模版。Spring通过模版封装来消除板式代码。Spring的jdbcTemplate使得执行数据库操作时，避免了传统的jdbc样式代码，把更多的尽力投入到自己的业务代码中。 总结 上面只是简单介绍的Spring的个别功能，而且还有更好的办法实现上面的功能，比如注解。这些只是Spring很少的一部分功能，其他的比如Spring web端的Spring MVC，持久层的Spring Data，简化Spring开发的Spring Boot等。 参考 Spring实战]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（六）：为博客添加站内搜索]]></title>
    <url>%2F2017%2F07%2F09%2FHello-Hexo%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前言 我们可以是用第三方服务來作为自己网站的站内搜索，开始想用百度的站内搜索，但是没成功，查询资料得知是因为百度站内搜索不支持https协议，所以只有换swiftype，这是国外的服务商，最好翻墙。 正文 注册在swiftype官网注册账号，提示免费是用7天，不过网上说过了这个期限也可以用，只不过功能少了，对于我们够用了。 创建搜索引擎注册登录后，点击create an engine–输入你的网址–给搜索引擎起名字： 创建好搜索后，过几分钟就可以看到从网站抓取的数据了： 安装配置成功后接下里就是在你的网站安装搜索功能了。点击左下的install Search显示搜索插件的代码， 用户可以根据自己需求是用swiftype提供的样式还是自定义，如果网站有定义好的搜索框样式可以点击Change Configuration按钮自定义自己的样式。 修改完后 点击Save Changes保存修改，点击Activate Swiftype激活。激活后复制插件的代码。 主题配置接下来就是配置主题了：首先把主题配置文件_config.yml中的搜索属性设置为true，我用的主题设置是： # 是否显示边栏中的搜索框 # Search Box in left column search_box: true 然后找到自己主题中关于搜索ejs文件，我的是themes\spfk\layout_partial\left-col.ejs 把在swiftype中设置的搜索框的代码copy进去。然后就是把搜索插件的代码放入网页中，swiftype上说把代码放到所有网站的网页中，我们可以放在一个公共的网页，我放的是themes\spfk\layout_partial\after-footer.ejs文件底部。 然后就是创建搜索结果页面，在themes\spfk\layout中创建search.ejs文件。文件内容是： &lt;% if(theme.search_box) { %&gt; &lt;div id=&quot;container&quot; class=&quot;page&quot;&gt; &lt;div id=&quot;st-results-container&quot; class = &quot;st-default-search-input&quot; style=&quot;width:80%&quot;&gt;正在加载搜索结果，请稍等。&lt;/div&gt; &lt;style&gt;.st-result-text { background: #fafafa; display: block; border-left: 0.5em solid #ccc; -webkit-transition: border-left 0.45s; -moz-transition: border-left 0.45s; -o-transition: border-left 0.45s; -ms-transition: border-left 0.45s; transition: border-left 0.45s; padding: 0.5em; } @media only screen and (min-width: 768px) { .st-result-text { padding: 1em; } } .st-result-text:hover { border-left: 0.5em solid #ea6753; } .st-result-text h3 a{ color: #2ca6cb; line-height: 1.5; font-size: 22px; } .st-snippet em { font-weight: bold; color: #ea6753; }&lt;/style&gt; &lt;!--注意下面到&lt;/script&gt;结束的代码块要替换成自己上面保存的Install Code代码--!&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(w,d,t,u,n,s,e){w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function(){ (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); })(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;6Rkyy_E5GJpZAdsHY_4k&apos;,&apos;2.0.0&apos;); &lt;/script&gt; &lt;% } %&gt; 现在搜索功能就已经完成了： 总结 第三方的站内搜索很多，如果有空，大家也可以试试其他的搜索。 参考 利用swiftype为hexo添加站内搜索v2.0]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（五）：博客部署到coding上]]></title>
    <url>%2F2017%2F07%2F08%2FHello-Hexo%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0coding%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[前言 coding是和github一样的国内的代码托管平台，部署方式和github类似。 正文 coding创建新项目想要把代码部署到coding上当然是要在coding官网注册账号。注册完后同样需要创建项目，相当于github的仓库： 项目建好后复制项目的ssh地址，或者https地址 然后在博客的_config.yml最下面配置： deploy: type: git repo: github: git@github.com:rick0407rick0407.github.io.git,master coding: https://git.coding.net/rick0407/rick0407.git,master tip：_config.yml文件是YAML标记语言，YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 把之前本地生成的.ssh公钥（id_rsa.pub文件中）配置到coding中 添加完后，准备工作就完成了，在git bash输入命令： ssh -T git@git.coding.net 遇到提示输入yes： 出现如上结果说明公钥添加成功。最后把博客同步到coding中： hexo deploy -g 同步后怎么才能像github那样访问自己的博客呢。coding访问自己项目的方式是 http://登陆名.coding.me/项目名 比如我的是 http://rick0407.coding.me/rick0407 如果你的项目名和登录名是一样的就可以省略项目名，直接输入 http://rick0407.coding.me 也可以访问，所以建议项目名和登录名相同。同步到coding后还不能直接访问，需要在Pages服务里面保存部署来源： 这样就可以直接访问你的博客了。 绑定域名把你的github地址和coding地址绑定到同一个域名下，实现国内的访问coding，国外访问github。在阿里云购买域名，（当然也可以在其他域名提供商购买），我们自己用就没必要购买.com的国际域名和白金词，最便宜的3元/年。购买后需要实名制和简单的配置。通过审核后就可以配置域名了，在博客根目录的source目录下创建CNAME文件（文件名称必须一样），没有后缀。文件的内容是你自己的域名，不带www,如yaotfly.com。添加后部署到github上和coding上面。部署到上面后，需要在coding网站上绑定自己的域名 绑定后，在域名控制台对自己的域名添加解析： 然后就可以访问自己的域名了，当你访问原部署的地址时，会自动跳到自己的域名下。 总结 到此，我们终于实现了部署一次github和coding同步部署了，访问速度也比之前快了很多，后面将为我们的博客添加站内搜索，让百度能狗收录我的博客 参考 hexo博客同时部署至github和Codinghexo博客添加域名实现双线部署（github和coding）]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（四）：部署源代码到github]]></title>
    <url>%2F2017%2F07%2F07%2FHello-Hexo%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%83%A8%E7%BD%B2%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[前言 现在我们是在一台计算机上编写博客，部署到github的代码是生成的静态化的网页。如果机器瘫痪，就失去了源代码，或者如果想要在另一台机器上继续完成未写完的文章，就需要获取之前的源代码，这就需要把源代码提交到github上。 正文 我们在github上创建仓库时默认只有一个分支：master,而这个分支时存放hexo博客生成的静态页面的，所以只能创建一个分支来存放博客的源代码。 创建分支创建分支有两种方法：第一种就是在你的github仓库中创建，进入仓库选择仓库页面的Branch按钮： 在输入框中填写分支名称回车就保存了分支。 更改默认分支添加完分支后需要修改新的分支为默认分支，点击仓库页面的Settings按钮进入仓库设置页面，设置新分支为默认分支： 这样你每次提交的代码就会提交到新的分支中了，而在其他终端clone的代码也会从此分支中下载。创建分支的第二种方式就是用命令： git checkout -b &lt;new branch name&gt; #创建分支并改为默认分支 建议使用第一种更直观些。 关于更多分支的知识可以参考Git分支管理 配置 tip：一下命令中都是用的我的github地址，需要替换你自己的地址 在博客根目录的_config.yml配置文件底部中添加配置： deploy: type: git repo: github: git@github.com:rick0407rick0407.github.io.git,master clone项目clone你的项目到博客根目录下： git clone https://github.com/rick0407/rick0407.github.io.git此命令是把分支的配置信息clone到本地，否则后面提交就会出现冲突。 提交代码执行一下代码将你的源代码提交到github分支中。 git remote add origin https://github.com/rick0407/rick0407.github.io.git #关联远程仓库 git add . #添加本地所有文件 git commit -m &quot;your desc&quot; #提交代码到git版本库中 git push -u origin branchName #把当前版本库中的代码提交到远程仓库分支中，其中branchName为默认分支的名称。 如果你已经使用了其他的主题，当你push源代码到github后，会发现在你的分支仓库中新的主题文件夹是灰色的而且打不开，其实是这个主题文件没有被提交到仓库中，这是因为当你clone主题时，也会把主题作者的git环境一同clone下来，这与你自己的git环境不同，就不会被提交到你的仓库中，而主题作者的git环境是在.git文件中，这个文件默认是隐藏的。这个问题也一直困扰我，一直没有找到好的解决办法，介绍一种比较笨但是有效的方法就是把主题文件剪切到其他位置，然后在themes文件夹下创建相同名称的文件夹，把除了隐藏文件.git之外其他文件copy进来，然后再重新提交，这样就会把主题提交到分支中了。 tip：我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令： git push origin branchName 在不同终端编写博客如果在另一台电脑上想继续写未完成的文章，就需要在这台电脑上同样配置nodejs、hexo、git、.ssh。安装好nodejs后执行： git clone https://github.com/rick0407/rick0407.github.io.git 然后在rick0407.github.io文件夹下通过 Git Base依次执行： npm install hexo npm install npm install hexo-deployer-git 然后就可以继续编写博客了，编写完成后执行以下命令部署静态网页： hexo g hexo d 然后执行以下命令把源代码提交到分支中： git add . git commit -m &quot;your desc&quot; git push origin branchName tip：每次编写博客开始前，需先执行命令: git pull origin branchName保持本地的版本和分支中的版本一致，然后再编写博客。 总结 本篇介绍了如何提交源代码到分支中以及如何在不同电脑上编写文章。hexo还有许多地方可以根据自己的爱好去修改，但是博客本身的内容比外表更重要，所以还是想办法提高博客的质量。后面的文章会介绍配置第三方服务如：站内搜索等。 参考 Git远程仓库Git分支管理]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（三）：发表文章]]></title>
    <url>%2F2017%2F07%2F07%2FHello-Hexo%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8F%91%E8%A1%A8%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言 博客框架已经搭建好了，配置文件也配置了，接下来就是写自己的博客了，本文介绍如何写自己的播客以及所用的语法。 正文 博客目录介绍在博客网站新建完后根目录的文件结构如下： . |—-_config.yml |—-package.json |—-scaffolds |—-source |&nbsp;&nbsp;&nbsp;&nbsp; |—-_drafts |&nbsp;&nbsp;&nbsp;&nbsp; |—-_posts |—-themes scaffolds为模版文件夹。当新建文章时，Hexo会根据sacffolds来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source为资源文件夹，是存放用户资源的地方。除了posts文件夹外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 新建一篇文章通过在shell中执行以下命令来创建一篇新文章 hexo new [layout] &lt;title&gt; layout为文章指定布局，默认为post，执行命令后，hexo在source/_post中创建了.md文件，文件名称就是文章的title。hexo使用的是markdown标记语言，所以写文章时要遵循markdown语法。你可以用notepad++编辑，也可以用其他如markdownpad编辑器。打开.md文件后里面已根据模版添加了一些内容： --- title: 文章标题 date: 2017-07-07 11:27:41 tags: --- title为文章标题date为发表时间，用户可以再配置文件中修改时间格式tags为文章的标签用户可以添加categories属性为文章添加类别，方便以后查找。详细的配置可以参考hexo官网文档。 为文章目录添加摘要我们刚建好的博客框架初始化了一篇文章：hello world，但是默认是显示全文的，如果之后文章数增多，页面看这比较乱，所以，可以设置文章目录显示摘要，或者只显示title，若想显示摘要，需在主题的配置文件中配置显示摘要的属性（具体配置每个主题不相同，可查看注释），然后在写博客时指定摘要的内容，具体有两种方法：一：在文章正文中添加 &lt;!--more--&gt; 则之前的文字就会作为摘要显示在目录下方。二：就是在文章头加上description属性，description的值就作为文章摘要显示在目录下方。 --- title: 文章标题 date: 2017-07-07 11:27:41 tags: description： 文章摘要 --- 为文章添加图片想要在文章中插入图片可以按照markdown语法来插入格式为 ![图片名称](图片地址) 图片的存放有两种方式：在本地D:\Hexo\source目录下新建一个存放图片的文件夹，比如images，然后把想要插入的图片放在里面，插入图片的路径；第二种方法是利用第三方网站（如：图床、七牛云存储）把图片上传到网络，然后插入图片路径。hexo3.x还提供了另一种解决方案：安装 post_asset_folder npm install https://github.com/CodeFalling/hexo-asset-image 把博客根目录中的post_asset_folder设置为true,这样在你每次新建一篇文章时，在source/_posts目录中都会增加一个同名的文件夹，利用一下语法来引用图片： {% asset_link slug [title] %} 如： {% asset_img example.jpg This is an example image %} 插入音乐我们还可以利用第三方音乐生成外链放入文章中添加音乐： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=432506345&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 然后页面上就会出现播放器： tip:网易云音乐外链中auto=1时会自动播放，设置为0时为手动播放。我们也可以手动修改宽高等属性。 同理，我们也可以插入视频播放器等让自己的文章绘声绘色。 总结 这片文章简要介绍了新建文章以及编辑文章的方法，具体markdown语法可参考以上网站。我们写完博客后需要部署到github上可以再外网上浏览，但是github上存放的只是生成后的静态页面而不是源代码，如果我们编写博客的电脑发生故障就会丢失源代码，这是很危险的，下一篇就介绍如果把源代码提交到github以及如何在不同计算机上写博客。 参考 markdown语法 hexo基本操作]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（二）：hexo主题及网站基本配置]]></title>
    <url>%2F2017%2F07%2F07%2FHello-Hexo%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 上一篇介绍如何用hexo+hexo搭建自己的播客，hexo默认的主题是landsacpe，如果不喜欢也可以从github上面选择自己喜欢的主题。本篇介绍一下我自己用的主题配置 正文 安装主题进入hexo主题网页选择自己喜欢的主题，这里面列出的都是其他网友制作的主题，点击主题图片可以预览，喜欢哪个就点击主题名称进入github复制网址输入指令： git clone https://github.com/luuman/hexo-theme-spfk themes/spfk 这样主题spfk就下载到本地了，位于博客网站根目录下的themes文件夹内 更换主题修改博客根目录下的_config.yml文件中的theme属性为spfk修改后启动 hexo server -g #生成加预览 这样就成功更换了主题 修改配置信息主题更换后，里面的部分内容如博客名称目录显示的是主题作者的信息，需要改成自己的信息，每一个作者做出的主题的配置项是不一样，但基本的配置是大致相同的，这里只介绍基本的配置，其他内容就需要自己探索了。在主题被下载到本地后，目录结构为 |主题目录结构 |—-languages |—-layout |—-source |—-.gitignore |—-_config.yml |—-README.md languages为主题所支持的语言layout为布局模版source存放主题的资源文件.gitignore的作用是忽略提交的文件_config&gt;yml为主题的配置信息README.md为主题作者的介绍 主题的配置信息在主题根目录下的_config.yml文件中，不建议使用系统自带记事本编辑，可能会出现中文乱码，如果使用notepad++进行编辑，要把编码改成utf-8编码。每一个主题的配置文件作者都做了大致的注释（也有可能是英文注释） menu: 博客: /Home 所有文章: / #指向博客首页 标签: /tags munu显示的是博客的目录，如果想添加自己的目录就按上面的格式添加，然后在博客根目录下的source文件夹内添加相应的文件夹。如：若想添加标签目录，在menu属性下添加 标签： /tags然后在source中创建tags文件夹，在tags文件夹中创建index.md文件，添加内容： layout: tags title:tags --- 这样在博客的目录中就添加了tags目录，只不过里面没有内容。如果想把博客的头像或者博客的背景改成自己喜欢的，就需要修改source文件中的内容了，博客中的图片、样式，js等都放在这里面，可以根据需要进行修改在主题的配置文件中还可以配置博客的作者名称、社交链接以及整合站内搜索、统计等第三方功能，这个在后面内容介绍。在博客根目录下的_config.yml配置文件中可以配置站点的信息具体配置可以参考hexo配置信息 总结 本文简要介绍了主题的配置和网站的基本信息配置，详细的配置需要参考hexo官网的介绍以及主题作者的注释信息。下一篇将介绍如何新建一篇博客。 参考 hexo主题列表hexo配置指南]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo（一）：github+hexo搭建博客]]></title>
    <url>%2F2017%2F07%2F04%2FHello-Hexo%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Agithub%2Bhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 作为一名不入流程序猿，遇到问题都是找其他人的博客，渐渐发现他们的博客都是相互借鉴的，第一个方法不合适，后面的都不用看了，所以自己也想做一个博客来记录自己遇到的问题，但是作为不喜欢随波逐流的人，当然不喜欢在第三方博客上写了，所以很早就萌生了自己搭建博客的想法，但一直没有动手做，因为不会。。。最近才听说hexo这个框架，平时工作忙，业余时间折腾了一周，终于出成果了，老泪纵横啊，然后赶快记录下自己的虐心过程，以此来开始我的博客生涯。 正文 我的软件环境是window系统用户，Hexo3版本 准备工作闲言碎语不多说，直接入正题hexo是运行再node.js环境下的，所以要下载安装Node.Js,安装过程略过。我们要把自己的博客托管到github上，所以要在github官网注册自己的账号.下载git用来管理自己的仓库 更详细的相关教程可以参考文末的网站 安装hexo安装好node.js和Git后就可以安装hexo了安装好node.js后，任意位置右键选择Git Bash Here选项安装好后会用到以下命令，#为注释： hexo g #用于生成静态文件 hexo s #用于启动服务器，可用来本地预览 hexo d #用于将本地文件发布到github上 hexo n #用于新建一片文章 输入安装hexo命令： npm install -g hexo 安装完成后，建一个文件夹（如：D:\HexoBlog），执行以下命令，Hexo自动在文件夹中建立网站所需所有文件： hexo init 安装依赖包： npm install 然后在D:\HexoBlog文件夹下执行以下命令： hexo g hexo s 然后用浏览器访问http://localhost:4000, 就可以看到部署在本地的博客了。 部署hexo到github以上只是把自己的博客部署到了本地，如果想让别人看到你的成果，那就需要把博客部署到外部服务器上，或者部署到github上。 注册github想要把代码部署到github上，当然要注册github账号，记住登录名，后面要用到。 创建仓库仓库用来存储代码，注册账号登录后创建一个仓库创建时，填写Repository name,仓库的名字格式为：yourname.github.io,其中yourname为注册github时的登录名。 本地文件部署到github想要把代码部署到github上，必须修改网站文件中的配置文件:_config.yml,建议使用Notepad++编辑。在_config.yml文件最下，添加如下配置： deploy: type: git repo: github: git@github.com:rick0407/rick0407.github.io.git,master 注意：hexo的配置文件中任何冒号后面都是带一个空格的，github的值是你仓库的cloneURL。配置完_config.yml后，如果是第一次使用github还需要配置SSH。在Git Bash Here中输入一下指令可以查看是否存在.ssh文件，如果有可以删除。 $ ls -al ~/.ssh total 34 drwxr-xr-x 1 RICK 197121 0 六月 27 17:16 ./ drwxr-xr-x 1 RICK 197121 0 七月 6 09:08 ../ -rw-r--r-- 1 RICK 197121 1679 六月 27 16:36 id_rsa -rw-r--r-- 1 RICK 197121 398 六月 27 16:36 id_rsa.pub -rw-r--r-- 1 RICK 197121 407 六月 27 17:16 known_hosts 输入一下指令后，提示输入用户名密码时不用填写一路回车： ssh-keygen -t rsa -C &quot;注册github时的邮箱&quot; 然后输入一下指令 ssh-agent -s 继续输入 ssh-add ~/.ssh/id_rsa 输入后如果出现could not open a connection to your authentication agent错误就先输入 ssh-agent bash 然后继续执行上一条指令成功后就可以添加SSH key到你的github账户了。复制本地id_rsa.pub中的内容（C:\Users\administrator.ssh\id_rsa.pub）到github中复制后可以测试一下，输入一下指令 ssh -T git@github.com 如果有警告输入”yes”就行最后要安装hexo-deployer-git模块 npm install hexo-deployer-git --save 安装好后执行以下命令 hexo g #生成静态文件 hexo d #部署 部署后在地址栏输入yourname.github.io就可以访问了，比如我的是rick0407.github.io 总结 到此就成功创建了一个hexo博客网站，这只是最基本的流程，hexo支持许多插件，和好看的主题，可以让你的博客页面更好看，后面会增加一些插件，更换主题。 参考 hexo中文网 nodejs中文网 Git教程]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
      <tags>
        <tag>Hello Hexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
